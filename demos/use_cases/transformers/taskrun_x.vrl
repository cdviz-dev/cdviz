output = []
t0 = parse_timestamp!(format_timestamp!(now(), format: "%FT00:00:00+00:00"), format: "%+")
t0 = to_unix_timestamp(t0) - to_int(parse_duration("6d", unit: "s") ?? 6*24*3600)
t0 = t0 + to_int(parse_duration(.body.dts_0, unit: "s") ?? 0.0)

for_each(["started", "finished"]) -> |_index, value| {
  delta_duration = -1.0
  if value == "started" && !is_nullish(.body.started) {
    delta_duration = parse_duration(.body.started, unit: "s") ?? -1.0
  } else if value == "finished" && !is_nullish(.body.finished) {
    delta_duration = parse_duration(.body.finished, unit: "s") ?? -1.0
  }
  if delta_duration >= 0.0 {
    delta_duration = delta_duration + (random_float(0.0, delta_duration * 0.2) ?? 0.0) # +/- 20%
    ts = from_unix_timestamp(t0 + to_int(delta_duration)) ?? now()
    ts = format_timestamp!(ts, format: "%+")
    task_name = to_string!(.body.taskName)
    event_type = "dev.cdevents.taskrun." + to_string!(value) + ".0.2.0"
    task_url = "https://www.example.com/task/" + task_name
    event = {
      "metadata": .metadata,
      "headers": .headers,
      "body": {
        "context": {
          "version": "0.4.1",
          "id": "0",
          "source": "/demo/use_cases",
          "type": event_type,
          "timestamp": ts,
        },
        "subject": {
          "id": .body.id,
          "type": "taskRun",
          "content": {
            "taskName": task_name,
            "url": task_url,
          }
        }
      }
    }
    # Add pipelineRun reference if present
    if !is_nullish(.body.pipelineRun_id) {
      event.body.subject.content.pipelineRun = {
        "id": .body.pipelineRun_id
      }
    }
    # Add outcome for finished events
    if value == "finished" && !is_nullish(.body.outcome) {
      event.body.subject.content.outcome = .body.outcome
    }
    output = push(output, event)
  }
}
output
